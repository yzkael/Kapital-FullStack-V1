{"mappings":"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","sources":["packages/@react-aria/autocomplete/src/useAutocomplete.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, BaseEvent, DOMProps, RefObject} from '@react-types/shared';\nimport {AriaTextFieldProps} from '@react-aria/textfield';\nimport {AutocompleteProps, AutocompleteState} from '@react-stately/autocomplete';\nimport {CLEAR_FOCUS_EVENT, FOCUS_EVENT, isCtrlKeyPressed, mergeProps, mergeRefs, UPDATE_ACTIVEDESCENDANT, useEffectEvent, useId, useLabels, useObjectRef} from '@react-aria/utils';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {KeyboardEvent as ReactKeyboardEvent, useCallback, useEffect, useMemo, useRef} from 'react';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface CollectionOptions extends DOMProps, AriaLabelingProps {\n  /** Whether the collection items should use virtual focus instead of being focused directly. */\n  shouldUseVirtualFocus: boolean,\n  /** Whether typeahead is disabled. */\n  disallowTypeAhead: boolean\n}\nexport interface AriaAutocompleteProps extends AutocompleteProps {\n  /**\n   * An optional filter function used to determine if a option should be included in the autocomplete list.\n   * Include this if the items you are providing to your wrapped collection aren't filtered by default.\n   */\n  filter?: (textValue: string, inputValue: string) => boolean\n}\n\nexport interface AriaAutocompleteOptions extends Omit<AriaAutocompleteProps, 'children'> {\n  /** The ref for the wrapped collection element. */\n  collectionRef: RefObject<HTMLElement | null>\n}\n\nexport interface AutocompleteAria {\n  /** Props for the autocomplete textfield/searchfield element. These should be passed to the textfield/searchfield aria hooks respectively. */\n  textFieldProps: AriaTextFieldProps,\n  /** Props for the collection, to be passed to collection's respective aria hook (e.g. useMenu). */\n  collectionProps: CollectionOptions,\n  /** Ref to attach to the wrapped collection. */\n  collectionRef: RefObject<HTMLElement | null>,\n  /** A filter function that returns if the provided collection node should be filtered out of the collection. */\n  filterFn?: (nodeTextValue: string) => boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for a autocomplete component.\n * A autocomplete combines a text input with a collection, allowing users to filter the collection's contents match a query.\n * @param props - Props for the autocomplete.\n * @param state - State for the autocomplete, as returned by `useAutocompleteState`.\n */\nexport function UNSTABLE_useAutocomplete(props: AriaAutocompleteOptions, state: AutocompleteState): AutocompleteAria {\n  let {\n    collectionRef,\n    filter\n  } = props;\n\n  let collectionId = useId();\n  let timeout = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let delayNextActiveDescendant = useRef(false);\n  let queuedActiveDescendant = useRef(null);\n  let lastCollectionNode = useRef<HTMLElement>(null);\n\n  let updateActiveDescendant = useEffectEvent((e) => {\n    let {target} = e;\n    if (queuedActiveDescendant.current === target.id) {\n      return;\n    }\n\n    clearTimeout(timeout.current);\n    e.stopPropagation();\n\n    if (target !== collectionRef.current) {\n      if (delayNextActiveDescendant.current) {\n        queuedActiveDescendant.current = target.id;\n        timeout.current = setTimeout(() => {\n          state.setFocusedNodeId(target.id);\n          queuedActiveDescendant.current = null;\n        }, 500);\n      } else {\n        state.setFocusedNodeId(target.id);\n      }\n    } else {\n      state.setFocusedNodeId(null);\n    }\n\n    delayNextActiveDescendant.current = false;\n  });\n\n  let callbackRef = useCallback((collectionNode) => {\n    if (collectionNode != null) {\n      // When typing forward, we want to delay the setting of active descendant to not interrupt the native screen reader announcement\n      // of the letter you just typed. If we recieve another UPDATE_ACTIVEDESCENDANT call then we clear the queued update\n      // We track lastCollectionNode to do proper cleanup since callbackRefs just pass null when unmounting. This also handles\n      // React 19's extra call of the callback ref in strict mode\n      lastCollectionNode.current?.removeEventListener(UPDATE_ACTIVEDESCENDANT, updateActiveDescendant);\n      lastCollectionNode.current = collectionNode;\n      collectionNode.addEventListener(UPDATE_ACTIVEDESCENDANT, updateActiveDescendant);\n    } else {\n      lastCollectionNode.current?.removeEventListener(UPDATE_ACTIVEDESCENDANT, updateActiveDescendant);\n    }\n  }, [updateActiveDescendant]);\n\n  // Make sure to memo so that React doesn't keep registering a new event listeners on every rerender of the wrapped collection\n  let mergedCollectionRef = useObjectRef(useMemo(() => mergeRefs(collectionRef, callbackRef), [collectionRef, callbackRef]));\n\n  let focusFirstItem = useEffectEvent(() => {\n    delayNextActiveDescendant.current = true;\n    collectionRef.current?.dispatchEvent(\n      new CustomEvent(FOCUS_EVENT, {\n        cancelable: true,\n        bubbles: true,\n        detail: {\n          focusStrategy: 'first'\n        }\n      })\n    );\n  });\n\n  let clearVirtualFocus = useEffectEvent(() => {\n    state.setFocusedNodeId(null);\n    let clearFocusEvent = new CustomEvent(CLEAR_FOCUS_EVENT, {\n      cancelable: true,\n      bubbles: true\n    });\n    clearTimeout(timeout.current);\n    delayNextActiveDescendant.current = false;\n    collectionRef.current?.dispatchEvent(clearFocusEvent);\n  });\n\n  // TODO: update to see if we can tell what kind of event (paste vs backspace vs typing) is happening instead\n  let onChange = (value: string) => {\n    // Tell wrapped collection to focus the first element in the list when typing forward and to clear focused key when deleting text\n    // for screen reader announcements\n    if (state.inputValue !== value && state.inputValue.length <= value.length) {\n      focusFirstItem();\n    } else {\n      clearVirtualFocus();\n    }\n\n    state.setInputValue(value);\n  };\n\n  let keyDownTarget = useRef<Element | null>(null);\n  // For textfield specific keydown operations\n  let onKeyDown = (e: BaseEvent<ReactKeyboardEvent<any>>) => {\n    keyDownTarget.current = e.target as Element;\n    if (e.nativeEvent.isComposing) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'a':\n        if (isCtrlKeyPressed(e)) {\n          return;\n        }\n        break;\n      case 'Escape':\n        // Early return for Escape here so it doesn't leak the Escape event from the simulated collection event below and\n        // close the dialog prematurely. Ideally that should be up to the discretion of the input element hence the check\n        // for isPropagationStopped\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        break;\n      case ' ':\n        // Space shouldn't trigger onAction so early return.\n\n        return;\n      case 'Home':\n      case 'End':\n      case 'PageDown':\n      case 'PageUp':\n      case 'ArrowUp':\n      case 'ArrowDown': {\n        if ((e.key === 'Home' || e.key === 'End') && state.focusedNodeId == null && e.shiftKey) {\n          return;\n        }\n\n        // Prevent these keys from moving the text cursor in the input\n        e.preventDefault();\n        // Move virtual focus into the wrapped collection\n        let focusCollection = new CustomEvent(FOCUS_EVENT, {\n          cancelable: true,\n          bubbles: true\n        });\n\n        collectionRef.current?.dispatchEvent(focusCollection);\n        break;\n      }\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        // TODO: will need to special case this so it doesn't clear the focused key if we are currently\n        // focused on a submenutrigger? May not need to since focus would\n        // But what about wrapped grids where ArrowLeft and ArrowRight should navigate left/right\n        clearVirtualFocus();\n        break;\n    }\n\n    // Emulate the keyboard events that happen in the input field in the wrapped collection. This is for triggering things like onAction via Enter\n    // or moving focus from one item to another. Stop propagation on the input event if it isn't already stopped so it doesn't leak out. For events\n    // like ESC, the dispatched event below will bubble out of the collection and be stopped if handled by useSelectableCollection, otherwise will bubble\n    // as expected\n    if (!e.isPropagationStopped()) {\n      e.stopPropagation();\n    }\n\n    if (state.focusedNodeId == null) {\n      collectionRef.current?.dispatchEvent(\n        new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n      );\n    } else {\n      let item = document.getElementById(state.focusedNodeId);\n      item?.dispatchEvent(\n        new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n      );\n    }\n  };\n\n  let onKeyUpCapture = useEffectEvent((e) => {\n    // Dispatch simulated key up events for things like triggering links in listbox\n    // Make sure to stop the propagation of the input keyup event so that the simulated keyup/down pair\n    // is detected by usePress instead of the original keyup originating from the input\n    if (e.target === keyDownTarget.current) {\n      e.stopImmediatePropagation();\n      if (state.focusedNodeId == null) {\n        collectionRef.current?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      } else {\n        let item = document.getElementById(state.focusedNodeId);\n        item?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      }\n    }\n  });\n\n  useEffect(() => {\n    document.addEventListener('keyup', onKeyUpCapture, true);\n    return () => {\n      document.removeEventListener('keyup', onKeyUpCapture, true);\n    };\n  }, [onKeyUpCapture]);\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/autocomplete');\n  let collectionProps = useLabels({\n    id: collectionId,\n    'aria-label': stringFormatter.format('collectionLabel')\n  });\n\n  let filterFn = useCallback((nodeTextValue: string) => {\n    if (filter) {\n      return filter(nodeTextValue, state.inputValue);\n    }\n\n    return true;\n  }, [state.inputValue, filter]);\n\n  return {\n    textFieldProps: {\n      value: state.inputValue,\n      onChange,\n      onKeyDown,\n      autoComplete: 'off',\n      'aria-haspopup': 'listbox',\n      'aria-controls': collectionId,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': state.focusedNodeId ?? undefined,\n      // This disable's iOS's autocorrect suggestions, since the autocomplete provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false'\n    },\n    collectionProps: mergeProps(collectionProps, {\n      // TODO: shouldFocusOnHover? shouldFocusWrap? Should it be up to the wrapped collection?\n      shouldUseVirtualFocus: true,\n      disallowTypeAhead: true\n    }),\n    collectionRef: mergedCollectionRef,\n    filterFn: filter != null ? filterFn : undefined\n  };\n}\n"],"names":[],"version":3,"file":"useAutocomplete.module.js.map"}