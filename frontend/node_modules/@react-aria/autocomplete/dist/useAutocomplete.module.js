import $4ELxY$intlStringsmodulejs from "./intlStrings.module.js";
import {useId as $4ELxY$useId, useEffectEvent as $4ELxY$useEffectEvent, UPDATE_ACTIVEDESCENDANT as $4ELxY$UPDATE_ACTIVEDESCENDANT, useObjectRef as $4ELxY$useObjectRef, mergeRefs as $4ELxY$mergeRefs, FOCUS_EVENT as $4ELxY$FOCUS_EVENT, CLEAR_FOCUS_EVENT as $4ELxY$CLEAR_FOCUS_EVENT, isCtrlKeyPressed as $4ELxY$isCtrlKeyPressed, useLabels as $4ELxY$useLabels, mergeProps as $4ELxY$mergeProps} from "@react-aria/utils";
import {useRef as $4ELxY$useRef, useCallback as $4ELxY$useCallback, useMemo as $4ELxY$useMemo, useEffect as $4ELxY$useEffect} from "react";
import {useLocalizedStringFormatter as $4ELxY$useLocalizedStringFormatter} from "@react-aria/i18n";


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
/*
 * Copyright 2024 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



function $48f6ba390f8c5b59$export$2d6947d4992da88e(props, state) {
    let { collectionRef: collectionRef, filter: filter } = props;
    let collectionId = (0, $4ELxY$useId)();
    let timeout = (0, $4ELxY$useRef)(undefined);
    let delayNextActiveDescendant = (0, $4ELxY$useRef)(false);
    let queuedActiveDescendant = (0, $4ELxY$useRef)(null);
    let lastCollectionNode = (0, $4ELxY$useRef)(null);
    let updateActiveDescendant = (0, $4ELxY$useEffectEvent)((e)=>{
        let { target: target } = e;
        if (queuedActiveDescendant.current === target.id) return;
        clearTimeout(timeout.current);
        e.stopPropagation();
        if (target !== collectionRef.current) {
            if (delayNextActiveDescendant.current) {
                queuedActiveDescendant.current = target.id;
                timeout.current = setTimeout(()=>{
                    state.setFocusedNodeId(target.id);
                    queuedActiveDescendant.current = null;
                }, 500);
            } else state.setFocusedNodeId(target.id);
        } else state.setFocusedNodeId(null);
        delayNextActiveDescendant.current = false;
    });
    let callbackRef = (0, $4ELxY$useCallback)((collectionNode)=>{
        var _lastCollectionNode_current;
        if (collectionNode != null) {
            var // When typing forward, we want to delay the setting of active descendant to not interrupt the native screen reader announcement
            // of the letter you just typed. If we recieve another UPDATE_ACTIVEDESCENDANT call then we clear the queued update
            // We track lastCollectionNode to do proper cleanup since callbackRefs just pass null when unmounting. This also handles
            // React 19's extra call of the callback ref in strict mode
            _lastCollectionNode_current1;
            (_lastCollectionNode_current1 = lastCollectionNode.current) === null || _lastCollectionNode_current1 === void 0 ? void 0 : _lastCollectionNode_current1.removeEventListener((0, $4ELxY$UPDATE_ACTIVEDESCENDANT), updateActiveDescendant);
            lastCollectionNode.current = collectionNode;
            collectionNode.addEventListener((0, $4ELxY$UPDATE_ACTIVEDESCENDANT), updateActiveDescendant);
        } else (_lastCollectionNode_current = lastCollectionNode.current) === null || _lastCollectionNode_current === void 0 ? void 0 : _lastCollectionNode_current.removeEventListener((0, $4ELxY$UPDATE_ACTIVEDESCENDANT), updateActiveDescendant);
    }, [
        updateActiveDescendant
    ]);
    // Make sure to memo so that React doesn't keep registering a new event listeners on every rerender of the wrapped collection
    let mergedCollectionRef = (0, $4ELxY$useObjectRef)((0, $4ELxY$useMemo)(()=>(0, $4ELxY$mergeRefs)(collectionRef, callbackRef), [
        collectionRef,
        callbackRef
    ]));
    let focusFirstItem = (0, $4ELxY$useEffectEvent)(()=>{
        var _collectionRef_current;
        delayNextActiveDescendant.current = true;
        (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(new CustomEvent((0, $4ELxY$FOCUS_EVENT), {
            cancelable: true,
            bubbles: true,
            detail: {
                focusStrategy: 'first'
            }
        }));
    });
    let clearVirtualFocus = (0, $4ELxY$useEffectEvent)(()=>{
        var _collectionRef_current;
        state.setFocusedNodeId(null);
        let clearFocusEvent = new CustomEvent((0, $4ELxY$CLEAR_FOCUS_EVENT), {
            cancelable: true,
            bubbles: true
        });
        clearTimeout(timeout.current);
        delayNextActiveDescendant.current = false;
        (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(clearFocusEvent);
    });
    // TODO: update to see if we can tell what kind of event (paste vs backspace vs typing) is happening instead
    let onChange = (value)=>{
        // Tell wrapped collection to focus the first element in the list when typing forward and to clear focused key when deleting text
        // for screen reader announcements
        if (state.inputValue !== value && state.inputValue.length <= value.length) focusFirstItem();
        else clearVirtualFocus();
        state.setInputValue(value);
    };
    let keyDownTarget = (0, $4ELxY$useRef)(null);
    // For textfield specific keydown operations
    let onKeyDown = (e)=>{
        var _collectionRef_current;
        keyDownTarget.current = e.target;
        if (e.nativeEvent.isComposing) return;
        switch(e.key){
            case 'a':
                if ((0, $4ELxY$isCtrlKeyPressed)(e)) return;
                break;
            case 'Escape':
                // Early return for Escape here so it doesn't leak the Escape event from the simulated collection event below and
                // close the dialog prematurely. Ideally that should be up to the discretion of the input element hence the check
                // for isPropagationStopped
                if (e.isDefaultPrevented()) return;
                break;
            case ' ':
                // Space shouldn't trigger onAction so early return.
                return;
            case 'Home':
            case 'End':
            case 'PageDown':
            case 'PageUp':
            case 'ArrowUp':
            case 'ArrowDown':
                {
                    var _collectionRef_current1;
                    if ((e.key === 'Home' || e.key === 'End') && state.focusedNodeId == null && e.shiftKey) return;
                    // Prevent these keys from moving the text cursor in the input
                    e.preventDefault();
                    // Move virtual focus into the wrapped collection
                    let focusCollection = new CustomEvent((0, $4ELxY$FOCUS_EVENT), {
                        cancelable: true,
                        bubbles: true
                    });
                    (_collectionRef_current1 = collectionRef.current) === null || _collectionRef_current1 === void 0 ? void 0 : _collectionRef_current1.dispatchEvent(focusCollection);
                    break;
                }
            case 'ArrowLeft':
            case 'ArrowRight':
                // TODO: will need to special case this so it doesn't clear the focused key if we are currently
                // focused on a submenutrigger? May not need to since focus would
                // But what about wrapped grids where ArrowLeft and ArrowRight should navigate left/right
                clearVirtualFocus();
                break;
        }
        // Emulate the keyboard events that happen in the input field in the wrapped collection. This is for triggering things like onAction via Enter
        // or moving focus from one item to another. Stop propagation on the input event if it isn't already stopped so it doesn't leak out. For events
        // like ESC, the dispatched event below will bubble out of the collection and be stopped if handled by useSelectableCollection, otherwise will bubble
        // as expected
        if (!e.isPropagationStopped()) e.stopPropagation();
        if (state.focusedNodeId == null) (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));
        else {
            let item = document.getElementById(state.focusedNodeId);
            item === null || item === void 0 ? void 0 : item.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));
        }
    };
    let onKeyUpCapture = (0, $4ELxY$useEffectEvent)((e)=>{
        // Dispatch simulated key up events for things like triggering links in listbox
        // Make sure to stop the propagation of the input keyup event so that the simulated keyup/down pair
        // is detected by usePress instead of the original keyup originating from the input
        if (e.target === keyDownTarget.current) {
            var _collectionRef_current;
            e.stopImmediatePropagation();
            if (state.focusedNodeId == null) (_collectionRef_current = collectionRef.current) === null || _collectionRef_current === void 0 ? void 0 : _collectionRef_current.dispatchEvent(new KeyboardEvent(e.type, e));
            else {
                let item = document.getElementById(state.focusedNodeId);
                item === null || item === void 0 ? void 0 : item.dispatchEvent(new KeyboardEvent(e.type, e));
            }
        }
    });
    (0, $4ELxY$useEffect)(()=>{
        document.addEventListener('keyup', onKeyUpCapture, true);
        return ()=>{
            document.removeEventListener('keyup', onKeyUpCapture, true);
        };
    }, [
        onKeyUpCapture
    ]);
    let stringFormatter = (0, $4ELxY$useLocalizedStringFormatter)((0, ($parcel$interopDefault($4ELxY$intlStringsmodulejs))), '@react-aria/autocomplete');
    let collectionProps = (0, $4ELxY$useLabels)({
        id: collectionId,
        'aria-label': stringFormatter.format('collectionLabel')
    });
    let filterFn = (0, $4ELxY$useCallback)((nodeTextValue)=>{
        if (filter) return filter(nodeTextValue, state.inputValue);
        return true;
    }, [
        state.inputValue,
        filter
    ]);
    var _state_focusedNodeId;
    return {
        textFieldProps: {
            value: state.inputValue,
            onChange: onChange,
            onKeyDown: onKeyDown,
            autoComplete: 'off',
            'aria-haspopup': 'listbox',
            'aria-controls': collectionId,
            // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
            'aria-autocomplete': 'list',
            'aria-activedescendant': (_state_focusedNodeId = state.focusedNodeId) !== null && _state_focusedNodeId !== void 0 ? _state_focusedNodeId : undefined,
            // This disable's iOS's autocorrect suggestions, since the autocomplete provides its own suggestions.
            autoCorrect: 'off',
            // This disable's the macOS Safari spell check auto corrections.
            spellCheck: 'false'
        },
        collectionProps: (0, $4ELxY$mergeProps)(collectionProps, {
            // TODO: shouldFocusOnHover? shouldFocusWrap? Should it be up to the wrapped collection?
            shouldUseVirtualFocus: true,
            disallowTypeAhead: true
        }),
        collectionRef: mergedCollectionRef,
        filterFn: filter != null ? filterFn : undefined
    };
}


export {$48f6ba390f8c5b59$export$2d6947d4992da88e as UNSTABLE_useAutocomplete};
//# sourceMappingURL=useAutocomplete.module.js.map
