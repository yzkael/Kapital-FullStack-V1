
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "CollectionNode", () => $499e2959ba1abacc$export$d68d59712b04d9d1);
$parcel$export(module.exports, "BaseCollection", () => $499e2959ba1abacc$export$408d25a4e12db025);
/*
 * Copyright 2024 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $499e2959ba1abacc$export$d68d59712b04d9d1 {
    get childNodes() {
        throw new Error('childNodes is not supported');
    }
    clone() {
        let node = new $499e2959ba1abacc$export$d68d59712b04d9d1(this.type, this.key);
        node.value = this.value;
        node.level = this.level;
        node.hasChildNodes = this.hasChildNodes;
        node.rendered = this.rendered;
        node.textValue = this.textValue;
        node['aria-label'] = this['aria-label'];
        node.index = this.index;
        node.parentKey = this.parentKey;
        node.prevKey = this.prevKey;
        node.nextKey = this.nextKey;
        node.firstChildKey = this.firstChildKey;
        node.lastChildKey = this.lastChildKey;
        node.props = this.props;
        node.render = this.render;
        return node;
    }
    constructor(type, key){
        this.value = null;
        this.level = 0;
        this.hasChildNodes = false;
        this.rendered = null;
        this.textValue = '';
        this['aria-label'] = undefined;
        this.index = 0;
        this.parentKey = null;
        this.prevKey = null;
        this.nextKey = null;
        this.firstChildKey = null;
        this.lastChildKey = null;
        this.props = {};
        this.type = type;
        this.key = key;
    }
}
class $499e2959ba1abacc$export$408d25a4e12db025 {
    get size() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    *[Symbol.iterator]() {
        let node = this.firstKey != null ? this.keyMap.get(this.firstKey) : undefined;
        while(node){
            yield node;
            node = node.nextKey != null ? this.keyMap.get(node.nextKey) : undefined;
        }
    }
    getChildren(key) {
        let keyMap = this.keyMap;
        return {
            *[Symbol.iterator] () {
                let parent = keyMap.get(key);
                let node = (parent === null || parent === void 0 ? void 0 : parent.firstChildKey) != null ? keyMap.get(parent.firstChildKey) : null;
                while(node){
                    yield node;
                    node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;
                }
            }
        };
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        if (!node) return null;
        if (node.prevKey != null) {
            node = this.keyMap.get(node.prevKey);
            while(node && node.type !== 'item' && node.lastChildKey != null)node = this.keyMap.get(node.lastChildKey);
            var _node_key;
            return (_node_key = node === null || node === void 0 ? void 0 : node.key) !== null && _node_key !== void 0 ? _node_key : null;
        }
        return node.parentKey;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        if (!node) return null;
        if (node.type !== 'item' && node.firstChildKey != null) return node.firstChildKey;
        while(node){
            if (node.nextKey != null) return node.nextKey;
            if (node.parentKey != null) node = this.keyMap.get(node.parentKey);
            else return null;
        }
        return null;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        let node = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;
        while((node === null || node === void 0 ? void 0 : node.lastChildKey) != null)node = this.keyMap.get(node.lastChildKey);
        var _node_key;
        return (_node_key = node === null || node === void 0 ? void 0 : node.key) !== null && _node_key !== void 0 ? _node_key : null;
    }
    getItem(key) {
        var _this_keyMap_get;
        return (_this_keyMap_get = this.keyMap.get(key)) !== null && _this_keyMap_get !== void 0 ? _this_keyMap_get : null;
    }
    at() {
        throw new Error('Not implemented');
    }
    clone() {
        // We need to clone using this.constructor so that subclasses have the right prototype.
        // TypeScript isn't happy about this yet.
        // https://github.com/microsoft/TypeScript/issues/3841
        let Constructor = this.constructor;
        let collection = new Constructor();
        collection.keyMap = new Map(this.keyMap);
        collection.firstKey = this.firstKey;
        collection.lastKey = this.lastKey;
        return collection;
    }
    addNode(node) {
        if (this.frozen) throw new Error('Cannot add a node to a frozen collection');
        this.keyMap.set(node.key, node);
    }
    removeNode(key) {
        if (this.frozen) throw new Error('Cannot remove a node to a frozen collection');
        this.keyMap.delete(key);
    }
    commit(firstKey, lastKey, isSSR = false) {
        if (this.frozen) throw new Error('Cannot commit a frozen collection');
        this.firstKey = firstKey;
        this.lastKey = lastKey;
        this.frozen = !isSSR;
    }
    // TODO: this is pretty specific to menu, will need to check if it is generic enough
    // Will need to handle varying levels I assume but will revisit after I get searchable menu working for base menu
    // TODO: an alternative is to simply walk the collection and add all item nodes that match the filter and any sections/separators we encounter
    // to an array, then walk that new array and fix all the next/Prev keys while adding them to the new collection
    filter(filterFn) {
        let newCollection = new $499e2959ba1abacc$export$408d25a4e12db025();
        // This tracks the absolute last node we've visited in the collection when filtering, used for setting up the filteredCollection's lastKey and
        // for updating the next/prevKey for every non-filtered node.
        let lastNode = null;
        for (let node of this){
            if (node.type === 'section' && node.hasChildNodes) {
                let clonedSection = node.clone();
                let lastChildInSection = null;
                for (let child of this.getChildren(node.key))if (filterFn(child.textValue) || child.type === 'header') {
                    let clonedChild = child.clone();
                    // eslint-disable-next-line max-depth
                    if (lastChildInSection == null) clonedSection.firstChildKey = clonedChild.key;
                    // eslint-disable-next-line max-depth
                    if (newCollection.firstKey == null) newCollection.firstKey = clonedSection.key;
                    // eslint-disable-next-line max-depth
                    if (lastChildInSection && lastChildInSection.parentKey === clonedChild.parentKey) {
                        lastChildInSection.nextKey = clonedChild.key;
                        clonedChild.prevKey = lastChildInSection.key;
                    } else clonedChild.prevKey = null;
                    clonedChild.nextKey = null;
                    newCollection.addNode(clonedChild);
                    lastChildInSection = clonedChild;
                }
                // Add newly filtered section to collection if it has any valid child nodes, otherwise remove it and its header if any
                if (lastChildInSection) {
                    if (lastChildInSection.type !== 'header') {
                        clonedSection.lastChildKey = lastChildInSection.key;
                        // If the old prev section was filtered out, will need to attach to whatever came before
                        // eslint-disable-next-line max-depth
                        if (lastNode == null) clonedSection.prevKey = null;
                        else if (lastNode.type === 'section' || lastNode.type === 'separator') {
                            lastNode.nextKey = clonedSection.key;
                            clonedSection.prevKey = lastNode.key;
                        }
                        clonedSection.nextKey = null;
                        lastNode = clonedSection;
                        newCollection.addNode(clonedSection);
                    } else {
                        if (newCollection.firstKey === clonedSection.key) newCollection.firstKey = null;
                        newCollection.removeNode(lastChildInSection.key);
                    }
                }
            } else if (node.type === 'separator') {
                // will need to check if previous section key exists, if it does then we add the separator to the collection.
                // After the full collection is created we'll need to remove it it is the last node in the section (aka no following section after the separator)
                let clonedSeparator = node.clone();
                clonedSeparator.nextKey = null;
                if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) === 'section') {
                    lastNode.nextKey = clonedSeparator.key;
                    clonedSeparator.prevKey = lastNode.key;
                    lastNode = clonedSeparator;
                    newCollection.addNode(clonedSeparator);
                }
            } else if (filterFn(node.textValue)) {
                let clonedNode = node.clone();
                if (newCollection.firstKey == null) newCollection.firstKey = clonedNode.key;
                if (lastNode != null && lastNode.type !== 'section' && lastNode.type !== 'separator' && lastNode.parentKey === clonedNode.parentKey) {
                    lastNode.nextKey = clonedNode.key;
                    clonedNode.prevKey = lastNode.key;
                } else clonedNode.prevKey = null;
                clonedNode.nextKey = null;
                newCollection.addNode(clonedNode);
                lastNode = clonedNode;
            }
        }
        if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) === 'separator' && lastNode.nextKey === null) {
            let lastSection;
            if (lastNode.prevKey != null) {
                lastSection = newCollection.getItem(lastNode.prevKey);
                lastSection.nextKey = null;
            }
            newCollection.removeNode(lastNode.key);
            lastNode = lastSection;
        }
        newCollection.lastKey = (lastNode === null || lastNode === void 0 ? void 0 : lastNode.key) || null;
        return newCollection;
    }
    constructor(){
        this.keyMap = new Map();
        this.firstKey = null;
        this.lastKey = null;
        this.frozen = false;
    }
}


//# sourceMappingURL=BaseCollection.main.js.map
