{"mappings":";;;;;;;AAAA;;;;;;;;;;CAUC,GAUM,MAAM;IAuBX,IAAI,aAAgC;QAClC,MAAM,IAAI,MAAM;IAClB;IAEA,QAA2B;QACzB,IAAI,OAAmC,IAAI,0CAAe,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG;QAC7E,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,aAAa,GAAG,IAAI,CAAC,aAAa;QACvC,KAAK,QAAQ,GAAG,IAAI,CAAC,QAAQ;QAC7B,KAAK,SAAS,GAAG,IAAI,CAAC,SAAS;QAC/B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa;QACvC,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,SAAS,GAAG,IAAI,CAAC,SAAS;QAC/B,KAAK,OAAO,GAAG,IAAI,CAAC,OAAO;QAC3B,KAAK,OAAO,GAAG,IAAI,CAAC,OAAO;QAC3B,KAAK,aAAa,GAAG,IAAI,CAAC,aAAa;QACvC,KAAK,YAAY,GAAG,IAAI,CAAC,YAAY;QACrC,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,MAAM,GAAG,IAAI,CAAC,MAAM;QACzB,OAAO;IACT;IA1BA,YAAY,IAAY,EAAE,GAAQ,CAAE;aAf3B,QAAkB;aAClB,QAAgB;aAChB,gBAAyB;aACzB,WAAsB;aACtB,YAAoB;aACpB,gBAAwB;aACxB,QAAgB;aAChB,YAAwB;aACxB,UAAsB;aACtB,UAAsB;aACtB,gBAA4B;aAC5B,eAA2B;aAC3B,QAAa,CAAC;QAIrB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,GAAG,GAAG;IACb;AAwBF;AAOO,MAAM;IAMX,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI;IACzB;IAEA,UAAU;QACR,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI;IACzB;IAEA,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAG;QACnB,IAAI,OAA4B,IAAI,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,IAAI;QACzF,MAAO,KAAM;YACX,MAAM;YACN,OAAO,KAAK,OAAO,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,OAAO,IAAI;QAChE;IACF;IAEA,YAAY,GAAQ,EAAqB;QACvC,IAAI,SAAS,IAAI,CAAC,MAAM;QACxB,OAAO;YACL,CAAC,CAAC,OAAO,QAAQ,CAAC;gBAChB,IAAI,SAAS,OAAO,GAAG,CAAC;gBACxB,IAAI,OAAO,CAAA,mBAAA,6BAAA,OAAQ,aAAa,KAAI,OAAO,OAAO,GAAG,CAAC,OAAO,aAAa,IAAI;gBAC9E,MAAO,KAAM;oBACX,MAAM;oBACN,OAAO,KAAK,OAAO,IAAI,OAAO,OAAO,GAAG,CAAC,KAAK,OAAO,IAAI;gBAC3D;YACF;QACF;IACF;IAEA,aAAa,GAAQ,EAAE;QACrB,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC3B,IAAI,CAAC,MACH,OAAO;QAGT,IAAI,KAAK,OAAO,IAAI,MAAM;YACxB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,OAAO;YAEnC,MAAO,QAAQ,KAAK,IAAI,KAAK,UAAU,KAAK,YAAY,IAAI,KAC1D,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,YAAY;gBAGnC;YAAP,OAAO,CAAA,YAAA,iBAAA,2BAAA,KAAM,GAAG,cAAT,uBAAA,YAAa;QACtB;QAEA,OAAO,KAAK,SAAS;IACvB;IAEA,YAAY,GAAQ,EAAE;QACpB,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC3B,IAAI,CAAC,MACH,OAAO;QAGT,IAAI,KAAK,IAAI,KAAK,UAAU,KAAK,aAAa,IAAI,MAChD,OAAO,KAAK,aAAa;QAG3B,MAAO,KAAM;YACX,IAAI,KAAK,OAAO,IAAI,MAClB,OAAO,KAAK,OAAO;YAGrB,IAAI,KAAK,SAAS,IAAI,MACpB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS;iBAErC,OAAO;QAEX;QAEA,OAAO;IACT;IAEA,cAAc;QACZ,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA,aAAa;QACX,IAAI,OAAO,IAAI,CAAC,OAAO,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI;QAClE,MAAO,CAAA,iBAAA,2BAAA,KAAM,YAAY,KAAI,KAC3B,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,YAAY;YAGnC;QAAP,OAAO,CAAA,YAAA,iBAAA,2BAAA,KAAM,GAAG,cAAT,uBAAA,YAAa;IACtB;IAEA,QAAQ,GAAQ,EAAkB;YACzB;QAAP,OAAO,CAAA,mBAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAhB,8BAAA,mBAAwB;IACjC;IAEA,KAAc;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,QAAc;QACZ,uFAAuF;QACvF,yCAAyC;QACzC,sDAAsD;QACtD,IAAI,cAAmB,IAAI,CAAC,WAAW;QACvC,IAAI,aAAmB,IAAI;QAC3B,WAAW,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM;QACvC,WAAW,QAAQ,GAAG,IAAI,CAAC,QAAQ;QACnC,WAAW,OAAO,GAAG,IAAI,CAAC,OAAO;QACjC,OAAO;IACT;IAEA,QAAQ,IAAuB,EAAE;QAC/B,IAAI,IAAI,CAAC,MAAM,EACb,MAAM,IAAI,MAAM;QAGlB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;IAC5B;IAEA,WAAW,GAAQ,EAAE;QACnB,IAAI,IAAI,CAAC,MAAM,EACb,MAAM,IAAI,MAAM;QAGlB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;IACrB;IAEA,OAAO,QAAoB,EAAE,OAAmB,EAAE,QAAQ,KAAK,EAAE;QAC/D,IAAI,IAAI,CAAC,MAAM,EACb,MAAM,IAAI,MAAM;QAGlB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,MAAM,GAAG,CAAC;IACjB;IAEA,oFAAoF;IACpF,iHAAiH;IACjH,8IAA8I;IAC9I,+GAA+G;IAC/G,OAAO,QAAwC,EAAqB;QAClE,IAAI,gBAAgB,IAAI;QACxB,8IAA8I;QAC9I,6DAA6D;QAC7D,IAAI,WAA8C;QAElD,KAAK,IAAI,QAAQ,IAAI,CAAE;YACrB,IAAI,KAAK,IAAI,KAAK,aAAa,KAAK,aAAa,EAAE;gBACjD,IAAI,gBAA4C,AAAC,KAA2B,KAAK;gBACjF,IAAI,qBAAwD;gBAC5D,KAAK,IAAI,SAAS,IAAI,CAAC,WAAW,CAAC,KAAK,GAAG,EACzC,IAAI,SAAS,MAAM,SAAS,KAAK,MAAM,IAAI,KAAK,UAAU;oBACxD,IAAI,cAA0C,AAAC,MAA4B,KAAK;oBAChF,qCAAqC;oBACrC,IAAI,sBAAsB,MACxB,cAAc,aAAa,GAAG,YAAY,GAAG;oBAG/C,qCAAqC;oBACrC,IAAI,cAAc,QAAQ,IAAI,MAC5B,cAAc,QAAQ,GAAG,cAAc,GAAG;oBAG5C,qCAAqC;oBACrC,IAAI,sBAAsB,mBAAmB,SAAS,KAAK,YAAY,SAAS,EAAE;wBAChF,mBAAmB,OAAO,GAAG,YAAY,GAAG;wBAC5C,YAAY,OAAO,GAAG,mBAAmB,GAAG;oBAC9C,OACE,YAAY,OAAO,GAAG;oBAGxB,YAAY,OAAO,GAAG;oBACtB,cAAc,OAAO,CAAC;oBACtB,qBAAqB;gBACvB;gBAGF,sHAAsH;gBACtH,IAAI;oBACF,IAAI,mBAAmB,IAAI,KAAK,UAAU;wBACxC,cAAc,YAAY,GAAG,mBAAmB,GAAG;wBAEnD,wFAAwF;wBACxF,qCAAqC;wBACrC,IAAI,YAAY,MACd,cAAc,OAAO,GAAG;6BACnB,IAAI,SAAS,IAAI,KAAK,aAAa,SAAS,IAAI,KAAK,aAAa;4BACvE,SAAS,OAAO,GAAG,cAAc,GAAG;4BACpC,cAAc,OAAO,GAAG,SAAS,GAAG;wBACtC;wBACA,cAAc,OAAO,GAAG;wBACxB,WAAW;wBACX,cAAc,OAAO,CAAC;oBACxB,OAAO;wBACL,IAAI,cAAc,QAAQ,KAAK,cAAc,GAAG,EAC9C,cAAc,QAAQ,GAAG;wBAE3B,cAAc,UAAU,CAAC,mBAAmB,GAAG;oBACjD;;YAEJ,OAAO,IAAI,KAAK,IAAI,KAAK,aAAa;gBACpC,6GAA6G;gBAC7G,iJAAiJ;gBACjJ,IAAI,kBAA8C,AAAC,KAA2B,KAAK;gBACnF,gBAAgB,OAAO,GAAG;gBAC1B,IAAI,CAAA,qBAAA,+BAAA,SAAU,IAAI,MAAK,WAAW;oBAChC,SAAS,OAAO,GAAG,gBAAgB,GAAG;oBACtC,gBAAgB,OAAO,GAAG,SAAS,GAAG;oBACtC,WAAW;oBACX,cAAc,OAAO,CAAC;gBACxB;YACF,OAAO,IAAI,SAAS,KAAK,SAAS,GAAG;gBACnC,IAAI,aAAyC,AAAC,KAA2B,KAAK;gBAC9E,IAAI,cAAc,QAAQ,IAAI,MAC5B,cAAc,QAAQ,GAAG,WAAW,GAAG;gBAGzC,IAAI,YAAY,QAAS,SAAS,IAAI,KAAK,aAAa,SAAS,IAAI,KAAK,eAAgB,SAAS,SAAS,KAAK,WAAW,SAAS,EAAE;oBACrI,SAAS,OAAO,GAAG,WAAW,GAAG;oBACjC,WAAW,OAAO,GAAG,SAAS,GAAG;gBACnC,OACE,WAAW,OAAO,GAAG;gBAGvB,WAAW,OAAO,GAAG;gBACrB,cAAc,OAAO,CAAC;gBACtB,WAAW;YACb;QACF;QAEA,IAAI,CAAA,qBAAA,+BAAA,SAAU,IAAI,MAAK,eAAe,SAAS,OAAO,KAAK,MAAM;YAC/D,IAAI;YACJ,IAAI,SAAS,OAAO,IAAI,MAAM;gBAC5B,cAAc,cAAc,OAAO,CAAC,SAAS,OAAO;gBACpD,YAAY,OAAO,GAAG;YACxB;YACA,cAAc,UAAU,CAAC,SAAS,GAAG;YACrC,WAAW;QACb;QAEA,cAAc,OAAO,GAAG,CAAA,qBAAA,+BAAA,SAAU,GAAG,KAAI;QAEzC,OAAO;IACT;;aArPQ,SAAsC,IAAI;aAC1C,WAAuB;aACvB,UAAsB;aACtB,SAAS;;AAmPnB","sources":["packages/@react-aria/collections/src/BaseCollection.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection as ICollection, Key, Node} from '@react-types/shared';\nimport {ReactElement, ReactNode} from 'react';\n\nexport type Mutable<T> = {\n  -readonly[P in keyof T]: T[P]\n}\n\n/** An immutable object representing a Node in a Collection. */\nexport class CollectionNode<T> implements Node<T> {\n  readonly type: string;\n  readonly key: Key;\n  readonly value: T | null = null;\n  readonly level: number = 0;\n  readonly hasChildNodes: boolean = false;\n  readonly rendered: ReactNode = null;\n  readonly textValue: string = '';\n  readonly 'aria-label'?: string = undefined;\n  readonly index: number = 0;\n  readonly parentKey: Key | null = null;\n  readonly prevKey: Key | null = null;\n  readonly nextKey: Key | null = null;\n  readonly firstChildKey: Key | null = null;\n  readonly lastChildKey: Key | null = null;\n  readonly props: any = {};\n  readonly render?: (node: Node<any>) => ReactElement;\n\n  constructor(type: string, key: Key) {\n    this.type = type;\n    this.key = key;\n  }\n\n  get childNodes(): Iterable<Node<T>> {\n    throw new Error('childNodes is not supported');\n  }\n\n  clone(): CollectionNode<T> {\n    let node: Mutable<CollectionNode<T>> = new CollectionNode(this.type, this.key);\n    node.value = this.value;\n    node.level = this.level;\n    node.hasChildNodes = this.hasChildNodes;\n    node.rendered = this.rendered;\n    node.textValue = this.textValue;\n    node['aria-label'] = this['aria-label'];\n    node.index = this.index;\n    node.parentKey = this.parentKey;\n    node.prevKey = this.prevKey;\n    node.nextKey = this.nextKey;\n    node.firstChildKey = this.firstChildKey;\n    node.lastChildKey = this.lastChildKey;\n    node.props = this.props;\n    node.render = this.render;\n    return node;\n  }\n}\n\n/**\n * An immutable Collection implementation. Updates are only allowed\n * when it is not marked as frozen. This can be subclassed to implement\n * custom collection behaviors.\n */\nexport class BaseCollection<T> implements ICollection<Node<T>> {\n  private keyMap: Map<Key, CollectionNode<T>> = new Map();\n  private firstKey: Key | null = null;\n  private lastKey: Key | null = null;\n  private frozen = false;\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  *[Symbol.iterator]() {\n    let node: Node<T> | undefined = this.firstKey != null ? this.keyMap.get(this.firstKey) : undefined;\n    while (node) {\n      yield node;\n      node = node.nextKey != null ? this.keyMap.get(node.nextKey) : undefined;\n    }\n  }\n\n  getChildren(key: Key): Iterable<Node<T>> {\n    let keyMap = this.keyMap;\n    return {\n      *[Symbol.iterator]() {\n        let parent = keyMap.get(key);\n        let node = parent?.firstChildKey != null ? keyMap.get(parent.firstChildKey) : null;\n        while (node) {\n          yield node as Node<T>;\n          node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;\n        }\n      }\n    };\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    if (!node) {\n      return null;\n    }\n\n    if (node.prevKey != null) {\n      node = this.keyMap.get(node.prevKey);\n\n      while (node && node.type !== 'item' && node.lastChildKey != null) {\n        node = this.keyMap.get(node.lastChildKey);\n      }\n\n      return node?.key ?? null;\n    }\n\n    return node.parentKey;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    if (!node) {\n      return null;\n    }\n\n    if (node.type !== 'item' && node.firstChildKey != null) {\n      return node.firstChildKey;\n    }\n\n    while (node) {\n      if (node.nextKey != null) {\n        return node.nextKey;\n      }\n\n      if (node.parentKey != null) {\n        node = this.keyMap.get(node.parentKey);\n      } else {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    let node = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;\n    while (node?.lastChildKey != null) {\n      node = this.keyMap.get(node.lastChildKey);\n    }\n\n    return node?.key ?? null;\n  }\n\n  getItem(key: Key): Node<T> | null {\n    return this.keyMap.get(key) ?? null;\n  }\n\n  at(): Node<T> {\n    throw new Error('Not implemented');\n  }\n\n  clone(): this {\n    // We need to clone using this.constructor so that subclasses have the right prototype.\n    // TypeScript isn't happy about this yet.\n    // https://github.com/microsoft/TypeScript/issues/3841\n    let Constructor: any = this.constructor;\n    let collection: this = new Constructor();\n    collection.keyMap = new Map(this.keyMap);\n    collection.firstKey = this.firstKey;\n    collection.lastKey = this.lastKey;\n    return collection;\n  }\n\n  addNode(node: CollectionNode<T>) {\n    if (this.frozen) {\n      throw new Error('Cannot add a node to a frozen collection');\n    }\n\n    this.keyMap.set(node.key, node);\n  }\n\n  removeNode(key: Key) {\n    if (this.frozen) {\n      throw new Error('Cannot remove a node to a frozen collection');\n    }\n\n    this.keyMap.delete(key);\n  }\n\n  commit(firstKey: Key | null, lastKey: Key | null, isSSR = false) {\n    if (this.frozen) {\n      throw new Error('Cannot commit a frozen collection');\n    }\n\n    this.firstKey = firstKey;\n    this.lastKey = lastKey;\n    this.frozen = !isSSR;\n  }\n\n  // TODO: this is pretty specific to menu, will need to check if it is generic enough\n  // Will need to handle varying levels I assume but will revisit after I get searchable menu working for base menu\n  // TODO: an alternative is to simply walk the collection and add all item nodes that match the filter and any sections/separators we encounter\n  // to an array, then walk that new array and fix all the next/Prev keys while adding them to the new collection\n  filter(filterFn: (nodeValue: string) => boolean): BaseCollection<T> {\n    let newCollection = new BaseCollection<T>();\n    // This tracks the absolute last node we've visited in the collection when filtering, used for setting up the filteredCollection's lastKey and\n    // for updating the next/prevKey for every non-filtered node.\n    let lastNode: Mutable<CollectionNode<T>> | null = null;\n\n    for (let node of this) {\n      if (node.type === 'section' && node.hasChildNodes) {\n        let clonedSection: Mutable<CollectionNode<T>> = (node as CollectionNode<T>).clone();\n        let lastChildInSection: Mutable<CollectionNode<T>> | null = null;\n        for (let child of this.getChildren(node.key)) {\n          if (filterFn(child.textValue) || child.type === 'header') {\n            let clonedChild: Mutable<CollectionNode<T>> = (child as CollectionNode<T>).clone();\n            // eslint-disable-next-line max-depth\n            if (lastChildInSection == null) {\n              clonedSection.firstChildKey = clonedChild.key;\n            }\n\n            // eslint-disable-next-line max-depth\n            if (newCollection.firstKey == null) {\n              newCollection.firstKey = clonedSection.key;\n            }\n\n            // eslint-disable-next-line max-depth\n            if (lastChildInSection && lastChildInSection.parentKey === clonedChild.parentKey) {\n              lastChildInSection.nextKey = clonedChild.key;\n              clonedChild.prevKey = lastChildInSection.key;\n            } else {\n              clonedChild.prevKey = null;\n            }\n\n            clonedChild.nextKey = null;\n            newCollection.addNode(clonedChild);\n            lastChildInSection = clonedChild;\n          }\n        }\n\n        // Add newly filtered section to collection if it has any valid child nodes, otherwise remove it and its header if any\n        if (lastChildInSection) {\n          if (lastChildInSection.type !== 'header') {\n            clonedSection.lastChildKey = lastChildInSection.key;\n\n            // If the old prev section was filtered out, will need to attach to whatever came before\n            // eslint-disable-next-line max-depth\n            if (lastNode == null) {\n              clonedSection.prevKey = null;\n            } else if (lastNode.type === 'section' || lastNode.type === 'separator') {\n              lastNode.nextKey = clonedSection.key;\n              clonedSection.prevKey = lastNode.key;\n            }\n            clonedSection.nextKey = null;\n            lastNode = clonedSection;\n            newCollection.addNode(clonedSection);\n          } else {\n            if (newCollection.firstKey === clonedSection.key) {\n              newCollection.firstKey = null;\n            }\n            newCollection.removeNode(lastChildInSection.key);\n          }\n        }\n      } else if (node.type === 'separator') {\n        // will need to check if previous section key exists, if it does then we add the separator to the collection.\n        // After the full collection is created we'll need to remove it it is the last node in the section (aka no following section after the separator)\n        let clonedSeparator: Mutable<CollectionNode<T>> = (node as CollectionNode<T>).clone();\n        clonedSeparator.nextKey = null;\n        if (lastNode?.type === 'section') {\n          lastNode.nextKey = clonedSeparator.key;\n          clonedSeparator.prevKey = lastNode.key;\n          lastNode = clonedSeparator;\n          newCollection.addNode(clonedSeparator);\n        }\n      } else if (filterFn(node.textValue)) {\n        let clonedNode: Mutable<CollectionNode<T>> = (node as CollectionNode<T>).clone();\n        if (newCollection.firstKey == null) {\n          newCollection.firstKey = clonedNode.key;\n        }\n\n        if (lastNode != null && (lastNode.type !== 'section' && lastNode.type !== 'separator') && lastNode.parentKey === clonedNode.parentKey) {\n          lastNode.nextKey = clonedNode.key;\n          clonedNode.prevKey = lastNode.key;\n        } else {\n          clonedNode.prevKey = null;\n        }\n\n        clonedNode.nextKey = null;\n        newCollection.addNode(clonedNode);\n        lastNode = clonedNode;\n      }\n    }\n\n    if (lastNode?.type === 'separator' && lastNode.nextKey === null) {\n      let lastSection;\n      if (lastNode.prevKey != null) {\n        lastSection = newCollection.getItem(lastNode.prevKey) as Mutable<CollectionNode<T>>;\n        lastSection.nextKey = null;\n      }\n      newCollection.removeNode(lastNode.key);\n      lastNode = lastSection;\n    }\n\n    newCollection.lastKey = lastNode?.key || null;\n\n    return newCollection;\n  }\n}\n"],"names":[],"version":3,"file":"BaseCollection.main.js.map"}