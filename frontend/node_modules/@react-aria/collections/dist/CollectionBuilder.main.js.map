{"mappings":"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","sources":["packages/@react-aria/collections/src/CollectionBuilder.tsx"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {BaseCollection} from './BaseCollection';\nimport {BaseNode, Document, ElementNode} from './Document';\nimport {CachedChildrenOptions, useCachedChildren} from './useCachedChildren';\nimport {createPortal} from 'react-dom';\nimport {forwardRefType, Node} from '@react-types/shared';\nimport {Hidden} from './Hidden';\nimport React, {createContext, ForwardedRef, forwardRef, JSX, ReactElement, ReactNode, useCallback, useContext, useMemo, useRef, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {useSyncExternalStore as useSyncExternalStoreShim} from 'use-sync-external-store/shim/index.js';\n\nconst ShallowRenderContext = createContext(false);\nconst CollectionDocumentContext = createContext<Document<any, BaseCollection<any>> | null>(null);\n\nexport interface CollectionBuilderProps<C extends BaseCollection<object>> {\n  content: ReactNode,\n  children: (collection: C) => ReactNode,\n  createCollection?: () => C\n}\n\n/**\n * Builds a `Collection` from the children provided to the `content` prop, and passes it to the child render prop function.\n */\nexport function CollectionBuilder<C extends BaseCollection<object>>(props: CollectionBuilderProps<C>): ReactElement {\n  // If a document was provided above us, we're already in a hidden tree. Just render the content.\n  let doc = useContext(CollectionDocumentContext);\n  if (doc) {\n    // The React types prior to 18 did not allow returning ReactNode from components\n    // even though the actual implementation since React 16 did.\n    // We must return ReactElement so that TS does not complain that <CollectionBuilder>\n    // is not a valid JSX element with React 16 and 17 types.\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/20544\n    return props.content as ReactElement;\n  }\n\n  // Otherwise, render a hidden copy of the children so that we can build the collection before constructing the state.\n  // This should always come before the real DOM content so we have built the collection by the time it renders during SSR.\n\n  // This is fine. CollectionDocumentContext never changes after mounting.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let {collection, document} = useCollectionDocument(props.createCollection);\n  return (\n    <>\n      <Hidden>\n        <CollectionDocumentContext.Provider value={document}>\n          {props.content}\n        </CollectionDocumentContext.Provider>\n      </Hidden>\n      <CollectionInner render={props.children} collection={collection} />\n    </>\n  );\n}\n\nfunction CollectionInner({collection, render}) {\n  return render(collection);\n}\n\ninterface CollectionDocumentResult<T, C extends BaseCollection<T>> {\n  collection: C,\n  document: Document<T, C>\n}\n\n// React 16 and 17 don't support useSyncExternalStore natively, and the shim provided by React does not support getServerSnapshot.\n// This wrapper uses the shim, but additionally calls getServerSnapshot during SSR (according to SSRProvider).\nfunction useSyncExternalStoreFallback<C>(subscribe: (onStoreChange: () => void) => () => void, getSnapshot: () => C, getServerSnapshot: () => C): C {\n  let isSSR = useIsSSR();\n  let isSSRRef = useRef(isSSR);\n  // This is read immediately inside the wrapper, which also runs during render.\n  // We just need a ref to avoid invalidating the callback itself, which\n  // would cause React to re-run the callback more than necessary.\n  // eslint-disable-next-line rulesdir/pure-render\n  isSSRRef.current = isSSR;\n\n  let getSnapshotWrapper = useCallback(() => {\n    return isSSRRef.current ? getServerSnapshot() : getSnapshot();\n  }, [getSnapshot, getServerSnapshot]);\n  return useSyncExternalStoreShim(subscribe, getSnapshotWrapper);\n}\n\nconst useSyncExternalStore = typeof React['useSyncExternalStore'] === 'function'\n  ? React['useSyncExternalStore']\n  : useSyncExternalStoreFallback;\n\nfunction useCollectionDocument<T extends object, C extends BaseCollection<T>>(createCollection?: () => C): CollectionDocumentResult<T, C> {\n  // The document instance is mutable, and should never change between renders.\n  // useSyncExternalStore is used to subscribe to updates, which vends immutable Collection objects.\n  let [document] = useState(() => new Document<T, C>(createCollection?.() || new BaseCollection() as C));\n  let subscribe = useCallback((fn: () => void) => document.subscribe(fn), [document]);\n  let getSnapshot = useCallback(() => {\n    let collection = document.getCollection();\n    if (document.isSSR) {\n      // After SSR is complete, reset the document to empty so it is ready for React to render the portal into.\n      // We do this _after_ getting the collection above so that the collection still has content in it from SSR\n      // during the current render, before React has finished the client render.\n      document.resetAfterSSR();\n    }\n    return collection;\n  }, [document]);\n  let getServerSnapshot = useCallback(() => {\n    document.isSSR = true;\n    return document.getCollection();\n  }, [document]);\n  let collection = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  useLayoutEffect(() => {\n    document.isMounted = true;\n    return () => {\n      // Mark unmounted so we can skip all of the collection updates caused by \n      // React calling removeChild on every item in the collection.\n      document.isMounted = false;\n    };\n  }, [document]);\n  return {collection, document};\n}\n\nconst SSRContext = createContext<BaseNode<any> | null>(null);\n\nfunction useSSRCollectionNode<T extends Element>(Type: string, props: object, ref: ForwardedRef<T>, rendered?: any, children?: ReactNode, render?: (node: Node<T>) => ReactElement) {\n  // During SSR, portals are not supported, so the collection children will be wrapped in an SSRContext.\n  // Since SSR occurs only once, we assume that the elements are rendered in order and never re-render.\n  // Therefore we can create elements in our collection document during render so that they are in the\n  // collection by the time we need to use the collection to render to the real DOM.\n  // After hydration, we switch to client rendering using the portal.\n  let itemRef = useCallback((element: ElementNode<any> | null) => {\n    element?.setProps(props, ref, rendered, render);\n  }, [props, ref, rendered, render]);\n  let parentNode = useContext(SSRContext);\n  if (parentNode) {\n    // Guard against double rendering in strict mode.\n    let element = parentNode.ownerDocument.nodesByProps.get(props);\n    if (!element) {\n      element = parentNode.ownerDocument.createElement(Type);\n      element.setProps(props, ref, rendered, render);\n      parentNode.appendChild(element);\n      parentNode.ownerDocument.updateCollection();\n      parentNode.ownerDocument.nodesByProps.set(props, element);\n    }\n\n    return children\n      ? <SSRContext.Provider value={element}>{children}</SSRContext.Provider>\n      : null;\n  }\n\n  // @ts-ignore\n  return <Type ref={itemRef}>{children}</Type>;\n}\n\nexport function createLeafComponent<T extends object, P extends object, E extends Element>(type: string, render: (props: P, ref: ForwardedRef<E>) => ReactElement): (props: P & React.RefAttributes<T>) => ReactElement | null;\nexport function createLeafComponent<T extends object, P extends object, E extends Element>(type: string, render: (props: P, ref: ForwardedRef<E>, node: Node<T>) => ReactElement): (props: P & React.RefAttributes<T>) => ReactElement | null;\nexport function createLeafComponent<P extends object, E extends Element>(type: string, render: (props: P, ref: ForwardedRef<E>, node?: any) => ReactElement) {\n  let Component = ({node}) => render(node.props, node.props.ref, node);\n  let Result = (forwardRef as forwardRefType)((props: P, ref: ForwardedRef<E>) => {\n    let isShallow = useContext(ShallowRenderContext);\n    if (!isShallow) {\n      if (render.length >= 3) {\n        throw new Error(render.name + ' cannot be rendered outside a collection.');\n      }\n      return render(props, ref);\n    }\n\n    return useSSRCollectionNode(type, props, ref, 'children' in props ? props.children : null, null, node => <Component node={node} />);\n  });\n  // @ts-ignore\n  Result.displayName = render.name;\n  return Result;\n}\n\nexport function createBranchComponent<T extends object, P extends {children?: any}, E extends Element>(type: string, render: (props: P, ref: ForwardedRef<E>, node: Node<T>) => ReactElement, useChildren: (props: P) => ReactNode = useCollectionChildren) {\n  let Component = ({node}) => render(node.props, node.props.ref, node);\n  let Result = (forwardRef as forwardRefType)((props: P, ref: ForwardedRef<E>) => {\n    let children = useChildren(props);\n    return useSSRCollectionNode(type, props, ref, null, children, node => <Component node={node} />) ?? <></>;\n  });\n  // @ts-ignore\n  Result.displayName = render.name;\n  return Result;\n}\n\nfunction useCollectionChildren<T extends object>(options: CachedChildrenOptions<T>) {\n  return useCachedChildren({...options, addIdAndValue: true});\n}\n\nexport interface CollectionProps<T> extends CachedChildrenOptions<T> {}\n\nconst CollectionContext = createContext<CachedChildrenOptions<unknown> | null>(null);\n\n/** A Collection renders a list of items, automatically managing caching and keys. */\nexport function Collection<T extends object>(props: CollectionProps<T>): JSX.Element {\n  let ctx = useContext(CollectionContext)!;\n  let dependencies = (ctx?.dependencies || []).concat(props.dependencies);\n  let idScope = props.idScope || ctx?.idScope;\n  let children = useCollectionChildren({\n    ...props,\n    idScope,\n    dependencies\n  });\n\n  let doc = useContext(CollectionDocumentContext);\n  if (doc) {\n    children = <CollectionRoot>{children}</CollectionRoot>;\n  }\n\n  // Propagate dependencies and idScope to child collections.\n  ctx = useMemo(() => ({\n    dependencies,\n    idScope\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [idScope, ...dependencies]);\n\n  return (\n    <CollectionContext.Provider value={ctx}>\n      {children}\n    </CollectionContext.Provider>\n  );\n}\n\nfunction CollectionRoot({children}) {\n  let doc = useContext(CollectionDocumentContext);\n  let wrappedChildren = useMemo(() => (\n    <CollectionDocumentContext.Provider value={null}>\n      <ShallowRenderContext.Provider value>\n        {children}\n      </ShallowRenderContext.Provider>\n    </CollectionDocumentContext.Provider>\n  ), [children]);\n  // During SSR, we render the content directly, and append nodes to the document during render.\n  // The collection children return null so that nothing is actually rendered into the HTML.\n  return useIsSSR()\n    ? <SSRContext.Provider value={doc}>{wrappedChildren}</SSRContext.Provider>\n    : createPortal(wrappedChildren, doc as unknown as Element);\n}\n"],"names":[],"version":3,"file":"CollectionBuilder.main.js.map"}